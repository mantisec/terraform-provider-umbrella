// Code generated by terraform-provider-umbrella generator. DO NOT EDIT.

package provider

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

// init registers this resource with the generated resource registry
func init() {
	RegisterGeneratedResource(NewCreateinternalnetworkResource)
}

// CreateinternalnetworkResource implements the createinternalnetwork resource
type CreateinternalnetworkResource struct {
	client *apiClient
}

// createinternalnetworkModel represents the resource data model
type createinternalnetworkModel struct {
	Id           types.String `tfsdk:"id"`
	IpAddress    types.String `tfsdk:"ip_address"`
	PrefixLength types.Int64  `tfsdk:"prefix_length"`
	SiteId       types.Int64  `tfsdk:"site_id"`
	NetworkId    types.Int64  `tfsdk:"network_id"`
	TunnelId     types.Int64  `tfsdk:"tunnel_id"`
	Name         types.String `tfsdk:"name"`
	TunnelName   types.String `tfsdk:"tunnel_name"`
	SiteName     types.String `tfsdk:"site_name"`
	NetworkName  types.String `tfsdk:"network_name"`
	CreatedAt    types.String `tfsdk:"created_at"`
	ModifiedAt   types.String `tfsdk:"modified_at"`
	OriginId     types.Int64  `tfsdk:"origin_id"`
}

// NewCreateinternalnetworkResource creates a new createinternalnetwork resource
func NewCreateinternalnetworkResource() resource.Resource {
	return &CreateinternalnetworkResource{}
}

// Metadata returns the resource type name
func (r *CreateinternalnetworkResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = "umbrella_createinternalnetwork"
}

// Configure configures the resource with the provider client
func (r *CreateinternalnetworkResource) Configure(_ context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*apiClient)
	if !ok {
		resp.Diagnostics.AddError("Unexpected Resource Configure Type", "Expected *apiClient")
		return
	}

	r.client = client
}

// Schema defines the resource schema
func (r *CreateinternalnetworkResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "createinternalnetwork resource",
		Attributes: map[string]schema.Attribute{
			"id":            schema.StringAttribute{Computed: true, Description: "Resource identifier"},
			"ip_address":    schema.StringAttribute{Required: true, Description: "The IPv4 address of the internal network."},
			"prefix_length": schema.Int64Attribute{Required: true, Description: "The length of the prefix. The prefix length is from 8 through 32."},
			"site_id":       schema.Int64Attribute{Optional: true, Description: "The site ID. For DNS policies, specify the ID of the site that is associated with internal network. Provide the value of either the `siteId`, `networkId`, or `tunnelId`."},
			"network_id":    schema.Int64Attribute{Optional: true, Description: "The network ID. For Web policies that use proxy chaining, specify the ID of the network, which is associated with the internal network. Provide the value of either the `siteId`, `networkId`, or `tunnelId`."},
			"tunnel_id":     schema.Int64Attribute{Optional: true, Description: "The ID of the tunnel. For Web policies that use an IPsec tunnel, specify the ID of tunnel, which is associated with the internal network. Provide the value of either the `siteId`, `networkId`, or `tunnelId`."},
			"name":          schema.StringAttribute{Required: true, Description: "The name of the internal network."},
			"tunnel_name":   schema.StringAttribute{Computed: true, Description: "The name of the tunnel associated with the internal network."},
			"site_name":     schema.StringAttribute{Computed: true, Description: "The name of the site associated with the internal network."},
			"network_name":  schema.StringAttribute{Computed: true, Description: "The name of the network associated with the internal network."},
			"created_at":    schema.StringAttribute{Computed: true, Description: "The date and time (ISO8601 timestamp) when the internal network was created."},
			"modified_at":   schema.StringAttribute{Computed: true, Description: "The date and time (ISO8601 timestamp) when the internal network was modified."},
			"origin_id":     schema.Int64Attribute{Computed: true, Description: "The origin ID of the internal network."},
		},
	}
}

// Create creates a new createinternalnetwork
func (r *CreateinternalnetworkResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var plan createinternalnetworkModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}
	// Create request body from plan
	requestBody := make(map[string]interface{})
	if !plan.IpAddress.IsNull() {
		requestBody["ip_address"] = plan.IpAddress.ValueString()
	}
	if !plan.PrefixLength.IsNull() {
		requestBody["prefix_length"] = plan.PrefixLength.ValueInt64()
	}
	if !plan.SiteId.IsNull() {
		requestBody["site_id"] = plan.SiteId.ValueInt64()
	}
	if !plan.NetworkId.IsNull() {
		requestBody["network_id"] = plan.NetworkId.ValueInt64()
	}
	if !plan.TunnelId.IsNull() {
		requestBody["tunnel_id"] = plan.TunnelId.ValueInt64()
	}
	if !plan.Name.IsNull() {
		requestBody["name"] = plan.Name.ValueString()
	}

	// Make API call
	result, err := r.client.CreateResource(ctx, "/internalnetworks", requestBody)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create createinternalnetwork, got error: %s", err))
		return
	}

	// Update state with response data
	if result.Data != nil {
		if dataMap, ok := result.Data.(map[string]interface{}); ok {
			if val, exists := dataMap["id"]; exists && val != nil {
				if strVal, ok := val.(string); ok {
					plan.Id = types.StringValue(strVal)
				}
			}
			if val, exists := dataMap["ip_address"]; exists && val != nil {
				if strVal, ok := val.(string); ok {
					plan.IpAddress = types.StringValue(strVal)
				}
			}
			if val, exists := dataMap["prefix_length"]; exists && val != nil {
				if floatVal, ok := val.(float64); ok {
					plan.PrefixLength = types.Int64Value(int64(floatVal))
				}
			}
			if val, exists := dataMap["site_id"]; exists && val != nil {
				if floatVal, ok := val.(float64); ok {
					plan.SiteId = types.Int64Value(int64(floatVal))
				}
			}
			if val, exists := dataMap["network_id"]; exists && val != nil {
				if floatVal, ok := val.(float64); ok {
					plan.NetworkId = types.Int64Value(int64(floatVal))
				}
			}
			if val, exists := dataMap["tunnel_id"]; exists && val != nil {
				if floatVal, ok := val.(float64); ok {
					plan.TunnelId = types.Int64Value(int64(floatVal))
				}
			}
			if val, exists := dataMap["name"]; exists && val != nil {
				if strVal, ok := val.(string); ok {
					plan.Name = types.StringValue(strVal)
				}
			}
			if val, exists := dataMap["tunnel_name"]; exists && val != nil {
				if strVal, ok := val.(string); ok {
					plan.TunnelName = types.StringValue(strVal)
				}
			}
			if val, exists := dataMap["site_name"]; exists && val != nil {
				if strVal, ok := val.(string); ok {
					plan.SiteName = types.StringValue(strVal)
				}
			}
			if val, exists := dataMap["network_name"]; exists && val != nil {
				if strVal, ok := val.(string); ok {
					plan.NetworkName = types.StringValue(strVal)
				}
			}
			if val, exists := dataMap["created_at"]; exists && val != nil {
				if strVal, ok := val.(string); ok {
					plan.CreatedAt = types.StringValue(strVal)
				}
			}
			if val, exists := dataMap["modified_at"]; exists && val != nil {
				if strVal, ok := val.(string); ok {
					plan.ModifiedAt = types.StringValue(strVal)
				}
			}
			if val, exists := dataMap["origin_id"]; exists && val != nil {
				if floatVal, ok := val.(float64); ok {
					plan.OriginId = types.Int64Value(int64(floatVal))
				}
			}
		}
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, plan)...)
}

// Read reads the createinternalnetwork
func (r *CreateinternalnetworkResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var state createinternalnetworkModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}
	// No specific read endpoint found - return current state
	// This is a no-op read that just returns the current state

	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

// Update updates the createinternalnetwork
func (r *CreateinternalnetworkResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var plan createinternalnetworkModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}
	// No specific update endpoint found
	resp.Diagnostics.AddError("Configuration Error", "No update endpoint configured for createinternalnetwork")
	return

	resp.Diagnostics.Append(resp.State.Set(ctx, plan)...)
}

// Delete deletes the createinternalnetwork
func (r *CreateinternalnetworkResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var state createinternalnetworkModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// No specific delete endpoint found
	resp.Diagnostics.AddError("Configuration Error", "No delete endpoint configured for createinternalnetwork")
}

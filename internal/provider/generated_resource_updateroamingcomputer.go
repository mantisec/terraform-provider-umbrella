// Code generated by terraform-provider-umbrella generator. DO NOT EDIT.

package provider

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

// init registers this resource with the generated resource registry
func init() {
	RegisterGeneratedResource(NewUpdateroamingcomputerResource)
}

// UpdateroamingcomputerResource implements the updateroamingcomputer resource
type UpdateroamingcomputerResource struct {
	client *apiClient
}

// updateroamingcomputerModel represents the resource data model
type updateroamingcomputerModel struct {
	Id                 types.String `tfsdk:"id"`
	Name               types.String `tfsdk:"name"`
	LastSyncStatus     types.String `tfsdk:"last_sync_status"`
	HasIpBlocking      types.Bool   `tfsdk:"has_ip_blocking"`
	Version            types.String `tfsdk:"version"`
	OsVersionName      types.String `tfsdk:"os_version_name"`
	AnyconnectDeviceId types.String `tfsdk:"anyconnect_device_id"`
	LastSync           types.String `tfsdk:"last_sync"`
	Type               types.String `tfsdk:"type"`
	SwgStatus          types.String `tfsdk:"swg_status"`
	OsVersion          types.String `tfsdk:"os_version"`
	DeviceId           types.String `tfsdk:"device_id"`
	LastSyncSwgStatus  types.String `tfsdk:"last_sync_swg_status"`
	AppliedBundle      types.Int64  `tfsdk:"applied_bundle"`
	OriginId           types.Int64  `tfsdk:"origin_id"`
}

// NewUpdateroamingcomputerResource creates a new updateroamingcomputer resource
func NewUpdateroamingcomputerResource() resource.Resource {
	return &UpdateroamingcomputerResource{}
}

// Metadata returns the resource type name
func (r *UpdateroamingcomputerResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = "umbrella_updateroamingcomputer"
}

// Configure configures the resource with the provider client
func (r *UpdateroamingcomputerResource) Configure(_ context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*apiClient)
	if !ok {
		resp.Diagnostics.AddError("Unexpected Resource Configure Type", "Expected *apiClient")
		return
	}

	r.client = client
}

// Schema defines the resource schema
func (r *UpdateroamingcomputerResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "updateroamingcomputer resource",
		Attributes: map[string]schema.Attribute{
			"id":                   schema.StringAttribute{Computed: true, Description: "Resource identifier"},
			"name":                 schema.StringAttribute{Required: true, Description: "The name of the roaming computer. `name` is a sequence of 1â€“50 characters."},
			"last_sync_status":     schema.StringAttribute{Computed: true, Description: "The status of the last sync on the roaming computer with DNS-layer security."},
			"has_ip_blocking":      schema.BoolAttribute{Computed: true, Description: "Specifies whether the roaming computer has IP blocking."},
			"version":              schema.StringAttribute{Computed: true, Description: "The version of the Cisco Secure Client with the Internet Security module deployed on the roaming computer."},
			"os_version_name":      schema.StringAttribute{Computed: true, Description: "The OS version name of the roaming computer."},
			"anyconnect_device_id": schema.StringAttribute{Computed: true, Description: "The ID of the device that has the Cisco Secure Client deployed with the Internet Security module."},
			"last_sync":            schema.StringAttribute{Computed: true, Description: "The date and time (timestamp) of the last sync."},
			"type":                 schema.StringAttribute{Computed: true, Description: "The type of the roaming computer."},
			"swg_status":           schema.StringAttribute{Computed: true, Description: "The status of the roaming computer with Internet security (Secure Web Gateway)."},
			"os_version":           schema.StringAttribute{Computed: true, Description: "The OS version of the roaming computer."},
			"device_id":            schema.StringAttribute{Computed: true, Description: "The hex ID of the roaming computer."},
			"last_sync_swg_status": schema.StringAttribute{Computed: true, Description: "The status of the last sync on the roaming computer with Internet security (Secure Web Gateway)."},
			"applied_bundle":       schema.Int64Attribute{Computed: true, Description: "The policy ID."},
			"origin_id":            schema.Int64Attribute{Computed: true, Description: "The origin ID for the roaming computer."},
		},
	}
}

// Create creates a new updateroamingcomputer
func (r *UpdateroamingcomputerResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var plan updateroamingcomputerModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}
	// No specific create endpoint found
	resp.Diagnostics.AddError("Configuration Error", "No create endpoint configured for updateroamingcomputer")
	return

	resp.Diagnostics.Append(resp.State.Set(ctx, plan)...)
}

// Read reads the updateroamingcomputer
func (r *UpdateroamingcomputerResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var state updateroamingcomputerModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}
	// No specific read endpoint found - return current state
	// This is a no-op read that just returns the current state

	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

// Update updates the updateroamingcomputer
func (r *UpdateroamingcomputerResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var plan updateroamingcomputerModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}
	// Create request body from plan
	requestBody := make(map[string]interface{})
	if !plan.Name.IsNull() {
		requestBody["name"] = plan.Name.ValueString()
	}

	// Build path with ID
	path := fmt.Sprintf("/roamingcomputers/{deviceId}", plan.Id.ValueString())

	// Make API call
	result, err := r.client.UpdateResource(ctx, path, requestBody)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update updateroamingcomputer, got error: %s", err))
		return
	}

	// Update state with response data
	if result.Data != nil {
		if dataMap, ok := result.Data.(map[string]interface{}); ok {
			if val, exists := dataMap["id"]; exists && val != nil {
				if strVal, ok := val.(string); ok {
					plan.Id = types.StringValue(strVal)
				}
			}
			if val, exists := dataMap["name"]; exists && val != nil {
				if strVal, ok := val.(string); ok {
					plan.Name = types.StringValue(strVal)
				}
			}
			if val, exists := dataMap["last_sync_status"]; exists && val != nil {
				if strVal, ok := val.(string); ok {
					plan.LastSyncStatus = types.StringValue(strVal)
				}
			}
			if val, exists := dataMap["has_ip_blocking"]; exists && val != nil {
				if boolVal, ok := val.(bool); ok {
					plan.HasIpBlocking = types.BoolValue(boolVal)
				}
			}
			if val, exists := dataMap["version"]; exists && val != nil {
				if strVal, ok := val.(string); ok {
					plan.Version = types.StringValue(strVal)
				}
			}
			if val, exists := dataMap["os_version_name"]; exists && val != nil {
				if strVal, ok := val.(string); ok {
					plan.OsVersionName = types.StringValue(strVal)
				}
			}
			if val, exists := dataMap["anyconnect_device_id"]; exists && val != nil {
				if strVal, ok := val.(string); ok {
					plan.AnyconnectDeviceId = types.StringValue(strVal)
				}
			}
			if val, exists := dataMap["last_sync"]; exists && val != nil {
				if strVal, ok := val.(string); ok {
					plan.LastSync = types.StringValue(strVal)
				}
			}
			if val, exists := dataMap["type"]; exists && val != nil {
				if strVal, ok := val.(string); ok {
					plan.Type = types.StringValue(strVal)
				}
			}
			if val, exists := dataMap["swg_status"]; exists && val != nil {
				if strVal, ok := val.(string); ok {
					plan.SwgStatus = types.StringValue(strVal)
				}
			}
			if val, exists := dataMap["os_version"]; exists && val != nil {
				if strVal, ok := val.(string); ok {
					plan.OsVersion = types.StringValue(strVal)
				}
			}
			if val, exists := dataMap["device_id"]; exists && val != nil {
				if strVal, ok := val.(string); ok {
					plan.DeviceId = types.StringValue(strVal)
				}
			}
			if val, exists := dataMap["last_sync_swg_status"]; exists && val != nil {
				if strVal, ok := val.(string); ok {
					plan.LastSyncSwgStatus = types.StringValue(strVal)
				}
			}
			if val, exists := dataMap["applied_bundle"]; exists && val != nil {
				if floatVal, ok := val.(float64); ok {
					plan.AppliedBundle = types.Int64Value(int64(floatVal))
				}
			}
			if val, exists := dataMap["origin_id"]; exists && val != nil {
				if floatVal, ok := val.(float64); ok {
					plan.OriginId = types.Int64Value(int64(floatVal))
				}
			}
		}
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, plan)...)
}

// Delete deletes the updateroamingcomputer
func (r *UpdateroamingcomputerResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var state updateroamingcomputerModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// No specific delete endpoint found
	resp.Diagnostics.AddError("Configuration Error", "No delete endpoint configured for updateroamingcomputer")
}

// Code generated by terraform-provider-umbrella generator. DO NOT EDIT.

package provider

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

// init registers this data source with the generated resource registry
func init() {
	RegisterGeneratedDataSource(NewGetcustomersubscriptiondetailsDataSource)
}

// GetcustomersubscriptiondetailsDataSource implements the getcustomersubscriptiondetails data source
type GetcustomersubscriptiondetailsDataSource struct {
	client *apiClient
}

// getcustomersubscriptiondetailsDataModel represents the data source data model
type getcustomersubscriptiondetailsDataModel struct {
	Id                          types.String `tfsdk:"id"`
	Organizationtypeid          types.Int64  `tfsdk:"organizationTypeId"`
	Packageid                   types.Int64  `tfsdk:"packageId"`
	Accountmanageremails        types.Set    `tfsdk:"accountManagerEmails"`
	Originid                    types.Int64  `tfsdk:"originId"`
	Adminemails                 types.Set    `tfsdk:"adminEmails"`
	Streetaddress               types.String `tfsdk:"streetAddress"`
	Isonboardingwizardcompleted types.Bool   `tfsdk:"isOnboardingWizardCompleted"`
	Trialid                     types.String `tfsdk:"trialId"`
	Accessrequeststate          types.String `tfsdk:"accessRequestState"`
	Trialextensioncount         types.Int64  `tfsdk:"trialExtensionCount"`
	Organizationid              types.Int64  `tfsdk:"organizationId"`
	Endsat                      types.String `tfsdk:"endsAt"`
	City                        types.String `tfsdk:"city"`
	Zipcode                     types.String `tfsdk:"zipCode"`
	Accessrequestid             types.Int64  `tfsdk:"accessRequestId"`
	Organizationname            types.String `tfsdk:"organizationName"`
	Subscriptionid              types.Int64  `tfsdk:"subscriptionId"`
	Packagename                 types.String `tfsdk:"packageName"`
	Streetaddress2              types.String `tfsdk:"streetAddress2"`
	Trialextendeddays           types.Int64  `tfsdk:"trialExtendedDays"`
	Createdat                   types.Int64  `tfsdk:"createdAt"`
	Countrycode                 types.String `tfsdk:"countryCode"`
	Users                       types.Int64  `tfsdk:"users"`
	Startsat                    types.String `tfsdk:"startsAt"`
	State                       types.String `tfsdk:"state"`
	Hasdistributorvisibility    types.Bool   `tfsdk:"hasDistributorVisibility"`
	Trialperiod                 types.String `tfsdk:"trialPeriod"`
	Modifiedat                  types.Int64  `tfsdk:"modifiedAt"`
	Packageinternalname         types.String `tfsdk:"packageInternalName"`
	Strength                    types.Object `tfsdk:"strength"`
	Dealid                      types.String `tfsdk:"dealId"`
	Ppovlifecycle               types.Object `tfsdk:"ppovLifecycle"`
}

// NewGetcustomersubscriptiondetailsDataSource creates a new getcustomersubscriptiondetails data source
func NewGetcustomersubscriptiondetailsDataSource() datasource.DataSource {
	return &GetcustomersubscriptiondetailsDataSource{}
}

// Metadata returns the data source type name
func (d *GetcustomersubscriptiondetailsDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = "umbrella_getcustomersubscriptiondetails"
}

// Configure configures the data source with the provider client
func (d *GetcustomersubscriptiondetailsDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*apiClient)
	if !ok {
		resp.Diagnostics.AddError("Unexpected DataSource Configure Type", "Expected *apiClient")
		return
	}

	d.client = client
}

// Schema defines the data source schema
func (d *GetcustomersubscriptiondetailsDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "getcustomersubscriptiondetails data source",
		Attributes: map[string]schema.Attribute{
			"id":                          schema.StringAttribute{Computed: true, Description: "Data source identifier"},
			"organizationTypeId":          schema.Int64Attribute{Computed: true, Description: "The type ID of the customer's organization."},
			"packageId":                   schema.Int64Attribute{Computed: true, Description: "The ID of the Umbrella package. To create or update a customer with either the SIG Essentials or SIG Advantage package, you must have a license for the selected package.  Package Id  Package Name  ::----  `99`  Umbrella Professional   `101`  Umbrella Platform   `107`  Umbrella Insights   `171`  Cisco Umbrella for Wireless LAN   `202`  Cisco Umbrella for EDU   `246`  Umbrella DNS Security Essentials   `248`  Umbrella DNS Security Advantage   `250`  Umbrella SIG Essentials   `252`  Umbrella SIG Advantage   `312`  Umbrella Not for Resale (NFR) MSP DNS Advantage  Note: The Umbrella NFR MSP DNS Advantage package (`312`) is only available in the Umbrella Secure MSP console."},
			"accountManagerEmails":        schema.SetAttribute{Computed: true, Description: "The emails of the account managers.", ElementType: types.StringType},
			"originId":                    schema.Int64Attribute{Computed: true, Description: "The origin ID created for the customer."},
			"adminEmails":                 schema.SetAttribute{Computed: true, Description: "The list of the administrator email addresses.", ElementType: types.StringType},
			"streetAddress":               schema.StringAttribute{Computed: true, Description: "The street address for the customer."},
			"isOnboardingWizardCompleted": schema.BoolAttribute{Computed: true, Description: "Specify whether the customer has logged into Umbrella."},
			"trialId":                     schema.StringAttribute{Computed: true, Description: "The MD5 value of the organization ID."},
			"accessRequestState":          schema.StringAttribute{Computed: true, Description: "The state of the access request."},
			"trialExtensionCount":         schema.Int64Attribute{Computed: true, Description: "The number of extensions that are applied to the trial."},
			"organizationId":              schema.Int64Attribute{Computed: true, Description: "The ID of the organization."},
			"endsAt":                      schema.StringAttribute{Computed: true, Description: "The end date of the subscription."},
			"city":                        schema.StringAttribute{Computed: true, Description: "The name of the city where the customer's organization is located."},
			"zipCode":                     schema.StringAttribute{Computed: true, Description: "The zip code of the customer's organization."},
			"accessRequestId":             schema.Int64Attribute{Computed: true, Description: "The ID of the access request to enable access to the child organization."},
			"organizationName":            schema.StringAttribute{Computed: true, Description: "The name of the customer's organization."},
			"subscriptionId":              schema.Int64Attribute{Computed: true, Description: "The ID of the subscription."},
			"packageName":                 schema.StringAttribute{Computed: true, Description: "The name of the Umbrella package. To create or update a customer with either the SIG Essentials or SIG Advantage package, you must have a license for the selected package.  Package Id  Package Name  ::----  `99`  Umbrella Professional   `101`  Umbrella Platform   `107`  Umbrella Insights   `171`  Cisco Umbrella for Wireless LAN   `202`  Cisco Umbrella for EDU   `246`  Umbrella DNS Security Essentials   `248`  Umbrella DNS Security Advantage   `250`  Umbrella SIG Essentials   `252`  Umbrella SIG Advantage   `312`  Umbrella Not for Resale (NFR) MSP DNS Advantage  Note: The Umbrella NFR MSP DNS Advantage package (`312`) is only available in the Umbrella Secure MSP console."},
			"streetAddress2":              schema.StringAttribute{Computed: true, Description: "The second street address for the customer."},
			"trialExtendedDays":           schema.Int64Attribute{Computed: true, Description: "The number of days to extend the trial."},
			"createdAt":                   schema.Int64Attribute{Computed: true, Description: "The time when the logo was created. Specify the time in milliseconds."},
			"countryCode":                 schema.StringAttribute{Computed: true, Description: "The country code of the customer's organization."},
			"users":                       schema.Int64Attribute{Computed: true, Description: "The number of users in the subscription."},
			"startsAt":                    schema.StringAttribute{Computed: true, Description: "The start date of the subscription."},
			"state":                       schema.StringAttribute{Computed: true, Description: "The name of the customer's state."},
			"hasDistributorVisibility":    schema.BoolAttribute{Computed: true, Description: "Specify whether the distributor has visibility into the trial."},
			"trialPeriod":                 schema.StringAttribute{Computed: true, Description: "The period of the trial, including the start and end times."},
			"modifiedAt":                  schema.Int64Attribute{Computed: true, Description: "The time when the logo was last modified. Specify the time in milliseconds."},
			"packageInternalName":         schema.StringAttribute{Computed: true, Description: "The internal name for the package."},
			"strength":                    schema.StringAttribute{Computed: true, Description: "The number of features consumed by a customer trial."},
			"dealId":                      schema.StringAttribute{Computed: true, Description: "The deal ID."},
			"ppovLifecycle":               schema.StringAttribute{Computed: true, Description: "The email details about lifecycle events from a customer trial."},
		},
	}
}

// Read reads the getcustomersubscriptiondetails data
func (d *GetcustomersubscriptiondetailsDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var config getcustomersubscriptiondetailsDataModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &config)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Read logic is now implemented in the template

	resp.Diagnostics.Append(resp.State.Set(ctx, &config)...)
}

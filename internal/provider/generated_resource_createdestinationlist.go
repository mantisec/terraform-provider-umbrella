// Code generated by terraform-provider-umbrella generator. DO NOT EDIT.

package provider

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

// init registers this resource with the generated resource registry
func init() {
	RegisterGeneratedResource(NewCreatedestinationlistResource)
}

// CreatedestinationlistResource implements the createdestinationlist resource
type CreatedestinationlistResource struct {
	client *apiClient
}

// createdestinationlistModel represents the resource data model
type createdestinationlistModel struct {
	Id                       types.String `tfsdk:"id"`
	Access                   types.String `tfsdk:"access"`
	IsGlobal                 types.Bool   `tfsdk:"is_global"`
	Name                     types.String `tfsdk:"name"`
	BundleTypeId             types.Int64  `tfsdk:"bundle_type_id"`
	Destinations             types.Set    `tfsdk:"destinations"`
	StatusCode               types.Int64  `tfsdk:"status_code"`
	StatusText               types.String `tfsdk:"status_text"`
	DataId                   types.Int64  `tfsdk:"data_id"`
	DataAccess               types.String `tfsdk:"data_access"`
	DataName                 types.String `tfsdk:"data_name"`
	DataModifiedAt           types.Int64  `tfsdk:"data_modified_at"`
	DataIsMspDefault         types.Bool   `tfsdk:"data_is_msp_default"`
	DataMetaApplicationCount types.Int64  `tfsdk:"data_meta_application_count"`
	DataMetaDestinationCount types.Int64  `tfsdk:"data_meta_destination_count"`
	DataMetaDomainCount      types.Int64  `tfsdk:"data_meta_domain_count"`
	DataMetaUrlCount         types.Int64  `tfsdk:"data_meta_url_count"`
	DataMetaIpv4Count        types.Int64  `tfsdk:"data_meta_ipv4_count"`
	DataOrganizationId       types.Int64  `tfsdk:"data_organization_id"`
	DataIsGlobal             types.Bool   `tfsdk:"data_is_global"`
	DataThirdpartyCategoryId types.Int64  `tfsdk:"data_thirdparty_category_id"`
	DataCreatedAt            types.Int64  `tfsdk:"data_created_at"`
	DataMarkedForDeletion    types.Bool   `tfsdk:"data_marked_for_deletion"`
	DataBundleTypeId         types.Int64  `tfsdk:"data_bundle_type_id"`
	MarkedForDeletion        types.Bool   `tfsdk:"marked_for_deletion"`
	OrganizationId           types.Int64  `tfsdk:"organization_id"`
	ThirdpartyCategoryId     types.Int64  `tfsdk:"thirdparty_category_id"`
	CreatedAt                types.Int64  `tfsdk:"created_at"`
	IsMspDefault             types.Bool   `tfsdk:"is_msp_default"`
	MetaDomainCount          types.Int64  `tfsdk:"meta_domain_count"`
	MetaUrlCount             types.Int64  `tfsdk:"meta_url_count"`
	MetaIpv4Count            types.Int64  `tfsdk:"meta_ipv4_count"`
	MetaApplicationCount     types.Int64  `tfsdk:"meta_application_count"`
	MetaDestinationCount     types.Int64  `tfsdk:"meta_destination_count"`
	ModifiedAt               types.Int64  `tfsdk:"modified_at"`
}

// NewCreatedestinationlistResource creates a new createdestinationlist resource
func NewCreatedestinationlistResource() resource.Resource {
	return &CreatedestinationlistResource{}
}

// Metadata returns the resource type name
func (r *CreatedestinationlistResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = "umbrella_createdestinationlist"
}

// Configure configures the resource with the provider client
func (r *CreatedestinationlistResource) Configure(_ context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*apiClient)
	if !ok {
		resp.Diagnostics.AddError("Unexpected Resource Configure Type", "Expected *apiClient")
		return
	}

	r.client = client
}

// Schema defines the resource schema
func (r *CreatedestinationlistResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "createdestinationlist resource",
		Attributes: map[string]schema.Attribute{
			"id":                          schema.StringAttribute{Computed: true, Description: "Resource identifier"},
			"access":                      schema.StringAttribute{Required: true, Description: "The type of access for the destination list."},
			"is_global":                   schema.BoolAttribute{Required: true, Description: "Specifies whether the destination list is a global destination list. There is only one default `allow` destination list and one default `block` destination list for an organization."},
			"name":                        schema.StringAttribute{Required: true, Description: "The name of the destination list."},
			"bundle_type_id":              schema.Int64Attribute{Optional: true, Description: "The type of the destination list in the policy. Set `1` for DNS, `2` for web, and `4` for SAML Bypass. If the field is not specified, the default value is `1`."},
			"destinations":                schema.SetAttribute{Optional: true, Description: "The list of destinations.", ElementType: types.StringType},
			"status_code":                 schema.Int64Attribute{Computed: true, Description: "The HTTP status code of the response."},
			"status_text":                 schema.StringAttribute{Computed: true, Description: "The HTTP message that describes the response."},
			"data_id":                     schema.Int64Attribute{Computed: true, Description: "The unique ID of the destination list."},
			"data_access":                 schema.StringAttribute{Computed: true, Description: "The type of access for the destination list."},
			"data_name":                   schema.StringAttribute{Computed: true, Description: "The name of the destination list."},
			"data_modified_at":            schema.Int64Attribute{Computed: true, Description: "The date and time when the destination list was modified."},
			"data_is_msp_default":         schema.BoolAttribute{Computed: true, Description: "Specifies whether MSP is the default."},
			"data_meta_application_count": schema.Int64Attribute{Computed: true, Description: "The total number of applications in a destination list. Applications are part of the total number of destinations in a destination list."},
			"data_meta_destination_count": schema.Int64Attribute{Computed: true, Description: "The total number of destinations in a destination list."},
			"data_meta_domain_count":      schema.Int64Attribute{Computed: true, Description: "The total number of domains in a destination list. Domains are part of the total number of destinations in a destination list."},
			"data_meta_url_count":         schema.Int64Attribute{Computed: true, Description: "The total number of URLs in a destination list. Urls are part of the total number of destinations in a destination list."},
			"data_meta_ipv4_count":        schema.Int64Attribute{Computed: true, Description: "The total number of IP addresses in a destination list. IP addresses are part of the total number of destinations in a destination list."},
			"data_organization_id":        schema.Int64Attribute{Computed: true, Description: "The organization ID."},
			"data_is_global":              schema.BoolAttribute{Computed: true, Description: "Specifies whether the destination list is a global destination list. There is only one default `allow` destination list and one default `block` destination list for an organization."},
			"data_thirdparty_category_id": schema.Int64Attribute{Computed: true, Description: "The third-party category ID of the destination list."},
			"data_created_at":             schema.Int64Attribute{Computed: true, Description: "The date and time when the destination list was created."},
			"data_marked_for_deletion":    schema.BoolAttribute{Computed: true, Description: "Specifies whether the destination list is marked for deletion."},
			"data_bundle_type_id":         schema.Int64Attribute{Computed: true, Description: "The type of the destination list in the policy. Set `1` for DNS, `2` for web, and `4` for SAML Bypass. If the field is not specified, the default value is `1`."},
			"marked_for_deletion":         schema.BoolAttribute{Computed: true, Description: "Specifies whether the destination list is marked for deletion."},
			"organization_id":             schema.Int64Attribute{Computed: true, Description: "The organization ID."},
			"thirdparty_category_id":      schema.Int64Attribute{Computed: true, Description: "The third-party category ID of the destination list."},
			"created_at":                  schema.Int64Attribute{Computed: true, Description: "The date and time when the destination list was created."},
			"is_msp_default":              schema.BoolAttribute{Computed: true, Description: "Specifies whether MSP is the default."},
			"meta_domain_count":           schema.Int64Attribute{Computed: true, Description: "The total number of domains in a destination list. Domains are part of the total number of destinations in a destination list."},
			"meta_url_count":              schema.Int64Attribute{Computed: true, Description: "The total number of URLs in a destination list. Urls are part of the total number of destinations in a destination list."},
			"meta_ipv4_count":             schema.Int64Attribute{Computed: true, Description: "The total number of IP addresses in a destination list. IP addresses are part of the total number of destinations in a destination list."},
			"meta_application_count":      schema.Int64Attribute{Computed: true, Description: "The total number of applications in a destination list. Applications are part of the total number of destinations in a destination list."},
			"meta_destination_count":      schema.Int64Attribute{Computed: true, Description: "The total number of destinations in a destination list."},
			"modified_at":                 schema.Int64Attribute{Computed: true, Description: "The date and time when the destination list was modified."},
		},
	}
}

// Create creates a new createdestinationlist
func (r *CreatedestinationlistResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var plan createdestinationlistModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}
	// Create request body from plan
	requestBody := make(map[string]interface{})
	if !plan.Access.IsNull() {
		requestBody["access"] = plan.Access.ValueString()
	}
	if !plan.IsGlobal.IsNull() {
		requestBody["is_global"] = plan.IsGlobal.ValueBool()
	}
	if !plan.Name.IsNull() {
		requestBody["name"] = plan.Name.ValueString()
	}
	if !plan.BundleTypeId.IsNull() {
		requestBody["bundle_type_id"] = plan.BundleTypeId.ValueInt64()
	}
	if !plan.Destinations.IsNull() {
		requestBody["destinations"] = plan.Destinations.ValueString()
	}

	// Make API call
	result, err := r.client.CreateResource(ctx, "/destinationlists", requestBody)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create createdestinationlist, got error: %s", err))
		return
	}

	// Update state with response data
	if result.Data != nil {
		if dataMap, ok := result.Data.(map[string]interface{}); ok {
			if val, exists := dataMap["id"]; exists && val != nil {
				if strVal, ok := val.(string); ok {
					plan.Id = types.StringValue(strVal)
				}
			}
			if val, exists := dataMap["access"]; exists && val != nil {
				if strVal, ok := val.(string); ok {
					plan.Access = types.StringValue(strVal)
				}
			}
			if val, exists := dataMap["is_global"]; exists && val != nil {
				if boolVal, ok := val.(bool); ok {
					plan.IsGlobal = types.BoolValue(boolVal)
				}
			}
			if val, exists := dataMap["name"]; exists && val != nil {
				if strVal, ok := val.(string); ok {
					plan.Name = types.StringValue(strVal)
				}
			}
			if val, exists := dataMap["bundle_type_id"]; exists && val != nil {
				if floatVal, ok := val.(float64); ok {
					plan.BundleTypeId = types.Int64Value(int64(floatVal))
				}
			}
			if val, exists := dataMap["destinations"]; exists && val != nil {
			}
			if val, exists := dataMap["status_code"]; exists && val != nil {
				if floatVal, ok := val.(float64); ok {
					plan.StatusCode = types.Int64Value(int64(floatVal))
				}
			}
			if val, exists := dataMap["status_text"]; exists && val != nil {
				if strVal, ok := val.(string); ok {
					plan.StatusText = types.StringValue(strVal)
				}
			}
			if val, exists := dataMap["data_id"]; exists && val != nil {
				if floatVal, ok := val.(float64); ok {
					plan.DataId = types.Int64Value(int64(floatVal))
				}
			}
			if val, exists := dataMap["data_access"]; exists && val != nil {
				if strVal, ok := val.(string); ok {
					plan.DataAccess = types.StringValue(strVal)
				}
			}
			if val, exists := dataMap["data_name"]; exists && val != nil {
				if strVal, ok := val.(string); ok {
					plan.DataName = types.StringValue(strVal)
				}
			}
			if val, exists := dataMap["data_modified_at"]; exists && val != nil {
				if floatVal, ok := val.(float64); ok {
					plan.DataModifiedAt = types.Int64Value(int64(floatVal))
				}
			}
			if val, exists := dataMap["data_is_msp_default"]; exists && val != nil {
				if boolVal, ok := val.(bool); ok {
					plan.DataIsMspDefault = types.BoolValue(boolVal)
				}
			}
			if val, exists := dataMap["data_meta_application_count"]; exists && val != nil {
				if floatVal, ok := val.(float64); ok {
					plan.DataMetaApplicationCount = types.Int64Value(int64(floatVal))
				}
			}
			if val, exists := dataMap["data_meta_destination_count"]; exists && val != nil {
				if floatVal, ok := val.(float64); ok {
					plan.DataMetaDestinationCount = types.Int64Value(int64(floatVal))
				}
			}
			if val, exists := dataMap["data_meta_domain_count"]; exists && val != nil {
				if floatVal, ok := val.(float64); ok {
					plan.DataMetaDomainCount = types.Int64Value(int64(floatVal))
				}
			}
			if val, exists := dataMap["data_meta_url_count"]; exists && val != nil {
				if floatVal, ok := val.(float64); ok {
					plan.DataMetaUrlCount = types.Int64Value(int64(floatVal))
				}
			}
			if val, exists := dataMap["data_meta_ipv4_count"]; exists && val != nil {
				if floatVal, ok := val.(float64); ok {
					plan.DataMetaIpv4Count = types.Int64Value(int64(floatVal))
				}
			}
			if val, exists := dataMap["data_organization_id"]; exists && val != nil {
				if floatVal, ok := val.(float64); ok {
					plan.DataOrganizationId = types.Int64Value(int64(floatVal))
				}
			}
			if val, exists := dataMap["data_is_global"]; exists && val != nil {
				if boolVal, ok := val.(bool); ok {
					plan.DataIsGlobal = types.BoolValue(boolVal)
				}
			}
			if val, exists := dataMap["data_thirdparty_category_id"]; exists && val != nil {
				if floatVal, ok := val.(float64); ok {
					plan.DataThirdpartyCategoryId = types.Int64Value(int64(floatVal))
				}
			}
			if val, exists := dataMap["data_created_at"]; exists && val != nil {
				if floatVal, ok := val.(float64); ok {
					plan.DataCreatedAt = types.Int64Value(int64(floatVal))
				}
			}
			if val, exists := dataMap["data_marked_for_deletion"]; exists && val != nil {
				if boolVal, ok := val.(bool); ok {
					plan.DataMarkedForDeletion = types.BoolValue(boolVal)
				}
			}
			if val, exists := dataMap["data_bundle_type_id"]; exists && val != nil {
				if floatVal, ok := val.(float64); ok {
					plan.DataBundleTypeId = types.Int64Value(int64(floatVal))
				}
			}
			if val, exists := dataMap["marked_for_deletion"]; exists && val != nil {
				if boolVal, ok := val.(bool); ok {
					plan.MarkedForDeletion = types.BoolValue(boolVal)
				}
			}
			if val, exists := dataMap["organization_id"]; exists && val != nil {
				if floatVal, ok := val.(float64); ok {
					plan.OrganizationId = types.Int64Value(int64(floatVal))
				}
			}
			if val, exists := dataMap["thirdparty_category_id"]; exists && val != nil {
				if floatVal, ok := val.(float64); ok {
					plan.ThirdpartyCategoryId = types.Int64Value(int64(floatVal))
				}
			}
			if val, exists := dataMap["created_at"]; exists && val != nil {
				if floatVal, ok := val.(float64); ok {
					plan.CreatedAt = types.Int64Value(int64(floatVal))
				}
			}
			if val, exists := dataMap["is_msp_default"]; exists && val != nil {
				if boolVal, ok := val.(bool); ok {
					plan.IsMspDefault = types.BoolValue(boolVal)
				}
			}
			if val, exists := dataMap["meta_domain_count"]; exists && val != nil {
				if floatVal, ok := val.(float64); ok {
					plan.MetaDomainCount = types.Int64Value(int64(floatVal))
				}
			}
			if val, exists := dataMap["meta_url_count"]; exists && val != nil {
				if floatVal, ok := val.(float64); ok {
					plan.MetaUrlCount = types.Int64Value(int64(floatVal))
				}
			}
			if val, exists := dataMap["meta_ipv4_count"]; exists && val != nil {
				if floatVal, ok := val.(float64); ok {
					plan.MetaIpv4Count = types.Int64Value(int64(floatVal))
				}
			}
			if val, exists := dataMap["meta_application_count"]; exists && val != nil {
				if floatVal, ok := val.(float64); ok {
					plan.MetaApplicationCount = types.Int64Value(int64(floatVal))
				}
			}
			if val, exists := dataMap["meta_destination_count"]; exists && val != nil {
				if floatVal, ok := val.(float64); ok {
					plan.MetaDestinationCount = types.Int64Value(int64(floatVal))
				}
			}
			if val, exists := dataMap["modified_at"]; exists && val != nil {
				if floatVal, ok := val.(float64); ok {
					plan.ModifiedAt = types.Int64Value(int64(floatVal))
				}
			}
		}
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, plan)...)
}

// Read reads the createdestinationlist
func (r *CreatedestinationlistResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var state createdestinationlistModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}
	// No specific read endpoint found - return current state
	// This is a no-op read that just returns the current state

	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

// Update updates the createdestinationlist
func (r *CreatedestinationlistResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var plan createdestinationlistModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}
	// No specific update endpoint found
	resp.Diagnostics.AddError("Configuration Error", "No update endpoint configured for createdestinationlist")
	return

	resp.Diagnostics.Append(resp.State.Set(ctx, plan)...)
}

// Delete deletes the createdestinationlist
func (r *CreatedestinationlistResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var state createdestinationlistModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// No specific delete endpoint found
	resp.Diagnostics.AddError("Configuration Error", "No delete endpoint configured for createdestinationlist")
}
